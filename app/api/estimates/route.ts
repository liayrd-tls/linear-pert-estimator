import { NextRequest, NextResponse } from 'next/server';
import { getLinearClientFromSession } from '@/lib/linear/client';

/**
 * Save PERT estimate as a Linear comment
 * Format: PERT: O=4h, M=6h, P=10h
 */
export async function POST(request: NextRequest) {
  try {
    const { issueId, estimate } = await request.json();

    if (!issueId || !estimate) {
      return NextResponse.json(
        { error: 'issueId and estimate are required' },
        { status: 400 }
      );
    }

    const client = await getLinearClientFromSession();

    if (!client) {
      return NextResponse.json(
        { error: 'Not authenticated. Please connect your Linear account.' },
        { status: 401 }
      );
    }

    const { optimistic, mostLikely, pessimistic } = estimate;

    // Create comment with PERT estimate
    const commentBody = `**PERT Estimate**
- Optimistic: ${optimistic}h
- Most Likely: ${mostLikely}h
- Pessimistic: ${pessimistic}h
- Expected: ${((optimistic + 4 * mostLikely + pessimistic) / 6).toFixed(1)}h

_Generated by PERT Estimator_`;

    const commentPayload = await client.createComment({
      issueId,
      body: commentBody,
    });

    const commentData = await commentPayload.comment;

    return NextResponse.json({
      success: true,
      commentId: commentData?.id,
      estimate,
    });
  } catch (error) {
    console.error('Error saving estimate:', error);
    return NextResponse.json(
      { error: 'Failed to save estimate as comment.' },
      { status: 500 }
    );
  }
}

/**
 * Get PERT estimate from Linear comments
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const issueId = searchParams.get('issueId');

    if (!issueId) {
      return NextResponse.json(
        { error: 'issueId is required' },
        { status: 400 }
      );
    }

    const client = await getLinearClientFromSession();

    if (!client) {
      return NextResponse.json(
        { error: 'Not authenticated.' },
        { status: 401 }
      );
    }

    const issue = await client.issue(issueId);
    const comments = await issue.comments();

    // Find the latest PERT estimate comment
    let latestEstimate = null;

    for (const comment of comments.nodes) {
      if (comment.body.includes('**PERT Estimate**')) {
        // Parse the estimate from the comment
        const optimisticMatch = comment.body.match(/Optimistic: ([\d.]+)h/);
        const mostLikelyMatch = comment.body.match(/Most Likely: ([\d.]+)h/);
        const pessimisticMatch = comment.body.match(/Pessimistic: ([\d.]+)h/);

        if (optimisticMatch && mostLikelyMatch && pessimisticMatch) {
          latestEstimate = {
            optimistic: parseFloat(optimisticMatch[1]),
            mostLikely: parseFloat(mostLikelyMatch[1]),
            pessimistic: parseFloat(pessimisticMatch[1]),
            commentId: comment.id,
            createdAt: comment.createdAt,
          };
        }
      }
    }

    return NextResponse.json({
      issueId,
      estimate: latestEstimate,
    });
  } catch (error) {
    console.error('Error fetching estimate:', error);
    return NextResponse.json(
      { error: 'Failed to fetch estimate.' },
      { status: 500 }
    );
  }
}
